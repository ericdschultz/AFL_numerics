"""
Quantum cat map functions.
"""

import numpy as np
from scipy.fft import fft,ifft

def cat_unitary(N, A):
    """
    Quantizes the classical cat map with matrix A to a N-dimensional unitary.
    Assumes there are no hidden symmetries that require use of the 'Gauss averages' function.
    """
    A11, A12, A21, A22 = A[0,0], A[0,1], A[1,0], A[1,1]
    if not (A11*A22 - A12*A21 == 1 and A11 + A22 > 2):
        raise ValueError("Invalid cat map matrix.")

    if np.gcd(A12, A22 - 1) > 1:
        raise ValueError('\n  This cat map requires computing the Gauss sum. Use cat_unitary_gauss() instead.')

    j,k = np.meshgrid(np.arange(N), np.arange(N), indexing='ij')
    
    arg = np.pi * (A22*j*j - 2*j*k + A11*k*k) / (N*A12)
    U = np.sqrt(A12/N) * np.exp(1j * arg)

    assert np.allclose(U @ U.conj().T, np.eye(N)), 'Map is not unitary'
    return U

def shear(N, kp, Hp, kq, Hq):
    """
    Returns the quantization of the shears along q and p generated by the given Hamiltonians.
    N - Hilbert space dimension
    kp and kq - perturbation strengths for shears along p and q respectively.
    Hp(q) - Generating Hamiltonian for shear along p function of one variable q.
    Hq(p) - Generating Hamiltonian for shear along q function of one variable p.
    If a Hamiltonian is passed as None, the corresponding shear is not applied.
    """
    points = np.arange(N) / N
    
    if Hp is None:
        P = np.eye(N)
    else:
        P = np.diag(np.exp(-2j * np.pi * N * kp * Hp(points)))
    if Hq is None:
        Q = np.eye(N)
    else:
        QinP = np.diag(np.exp(2j * np.pi * N * kq * Hq(points))) # in momentum space
        Q = ifft(fft(QinP, axis=1), axis=0) # p -> q basis

    return P @ Q

def max_pert(A, pmax, qmax):
    """
    Computes the maximum perturbation strength below which the cat map remains Anosov.
    A - Classical cat map matrix in SL(2,Z)
    pmax - Maximum magnitude of the second derivative of H(q), where H(q) generates the shear in p.
    qmax - Maximum magnitude of the second derivative of H(p), where H(p) generates the shear in q.

    This is obviously not the tightest bound, but it is the simplest to compute.
    """
    tr = A[0,0] + A[1,1]
    eigval = (tr - np.sqrt(tr**2 - 4)) / 2 # The lower eigenvalue
    pertvec = A @ np.array([qmax, pmax])
    maxpert = (1 - eigval) / np.sum(pertvec**2)
    return maxpert

def typ_pshear(N, k1, k2=0):
    """
    Returns the typical perturbation used for the quantum cat map.
    This is the shear along p of k1/2π * cos(2πq)
        generated by H(q) = -1/(2π)^2 * sin(2πq).
    We also include the option of a second shear long p of k2/4π * cos(4πq)
        generated by H(q) = -1/(4π)^2 * sin(4πq).
    This second shear breaks the W and R symmetries from Esposti and Winn.
    """
    H1 = lambda q: -np.sin(2*np.pi*q) / (2*np.pi)**2
    H2 = lambda q: -np.sin(4*np.pi*q) / (4*np.pi)**2
    H = lambda q: k1*H1(q) + k2*H2(q)
    return shear(N, 1, H, 0, None)

    
def cat_periodicity(N, A, max_time=None):
    """
    Computes the periodicity of the (unperturbed) quantum cat map.
    Returns None upon failure.
    """
    if max_time is None:
        max_time = 5 * N
    U = cat_unitary_gauss(N, A, 0)
    U_next = np.eye(N)
    for t in np.arange(max_time):
        U_next = U @ U_next
        diags = np.diag(U_next)
        # Period reached when U^t = exp(iϕ)I
        if np.allclose(U_next, np.diag(diags)) and np.allclose(diags, diags[0]):
            return t+1
    return None


def cat_R_vecs(N, s):
    """
    Sorts the eigenvectors of the cat map R operator by eigenvalue.
    Specifically, the R operator where β = 1/s.
    """
    # eigvecs has s charge blocks, each of size M (symmetric case)
    M = N // s
    inds = np.arange(M*s)
    # R in the q-basis is <j|R|k> = δ(jk)exp(i2πj/s)
    indmap = s*(inds % M) + inds // M
    charge_inds = np.arange(0, N, M)

    # Tail in the nonsymmetric case (s does not divide N)
    # The tail is size r = N % s, so the first r charge blocks have one extra vector
    r = N % s
    if r != 0:
        R = np.arange(r)
        indmap = np.insert(indmap, M*(R + 1), M*s + R)
        charge_inds = np.append(np.arange(0, (M+1)*r, M+1), np.arange((M+1)*r, N, M))

    eye = np.eye(N)
    # eigvecs[i,j] is the i-th component of the j-th eigenvector
    eigvecs = eye[:,indmap]
    return eigvecs, charge_inds

def cat_W(N):
    """
    Constructs the 4|N cat map symmetry operator W.
    Classically, W(q,p) = (1/2 - q, 1/2 - p).
    Quantization is possible for even N, where W|j> = (-1)^j |N/2 - j>.
    W is a symmetry when 4|N and W commutes with the applied perturbations.
    """
    if N % 2 != 0:
        raise ValueError("Cat map W is not defined for odd N.")
    W = np.zeros((N,N))
    for j in np.arange(N):
        W[N//2 - j, j] = (-1) ** j
    if N % 4 != 0:
        W = 1j*W # Ensures W is always Hermitian
    return W

def cat_W_vecs(N):
    """
    If 4|N, diagonalizes the cat map symmetry operator W (sorted by eigenvalue).
    We also return the indices where each charge sector begins.
    """
    if N % 4 != 0:
        raise ValueError("cat_W_vecs only supports the guaranteed symmetric case of 4|N.")
    
    '''
    W|j> = (-1)^j|N/2-j>
    
        0(8)              4
      7     1          5     3
    6         2  --> 6         2  (with phase factors)
      5     3          7     1 
         4                0

    The even but not 4|N case is not supported here.
        0(10)              5
      9     1           6     4
    8         2  -->  7         3  (with phase factors)
    7         3       8         2
      6     4           9     1
         5                0(10)
    '''
    # eigvecs[i,j] is the i-th component of the j-th eigenvector
    eigvecs = np.zeros((N,N))
    # +1 eigenvalues
    # We must alternate between symmetric and antisymmetric
    for i in range(1, N//2):
        eigvecs[i - N//4, i] = 1 / np.sqrt(2)
        eigvecs[N//2 + N//4 - i, i] = (1 - 2*(i % 2)) / np.sqrt(2)
    # This includes the two fixed points at N/4 and 3N/4
    # which are normalized differently
    eigvecs[-N//4, 0] = 1
    eigvecs[N//4, N//2] = 1

    # -1 eigenvalues
    # The opposite parity combinations
    for i in range(N//2 + 1, N):
        eigvecs[i - N//4, i] = 1 / np.sqrt(2)
        eigvecs[N//2 + N//4 - i, i] = (2*(i % 2) - 1) / np.sqrt(2)

    indices = np.array([0, N//2 + 1])
    return eigvecs, indices

def is_odd_prime(s):
    """
    Returns whether the given integer s is prime.
    """
    if s <= 1 or s % 2 == 0:
        return False
    for a in range(3, int(np.sqrt(s)) + 1, 2):
        if s % a == 0:
            return False
    return True


def nonabelian_dims(N, s):
    """
    The cat map R and W symmetries form a nonabelian algebra, which has a factor representation
        H = ⊕ (K ⊗ K') for irrep K and trivial space K'.
    See the paper for the explicit construction.
    This function returns the dimensions of K and K' as an array
    [[dim K_1, dim K'_1],
     [dim K_2, dim K'_2],
     ...]
    """
    if not (N % 4 == 0 and N % s == 0 and is_odd_prime(s)):
        raise ValueError("Only supports the symmetry algebra for N=sM with 4|M and s odd prime.")
    M = N // s
    irreps1D = np.array([[1, M//2+1],
                         [1, M//2-1]])
    irreps2D = np.repeat(np.array([[2, M]]), (s-1)//2, axis=0)
    dims = np.append(irreps1D, irreps2D, axis=0)
    return dims


def rep_to_qbasis(N, s):
    """
    The cat map R and W symmetries form a nonabelian algebra, which has a factor representation
        H = ⊕ (K ⊗ K') for irrep K and trivial space K'.
    See the paper for the explicit construction.
    This function returns the orthogonal map from this representation to the q-basis.
    for the simplified case of N = sM with 4|M and s an odd prime.
    """
    if not (N % 4 == 0 and N % s == 0 and is_odd_prime(s)):
        raise ValueError("Only supports the symmetry algebra for N=sM with 4|M and s odd prime.")
    M = N // s
    vecs_plus = np.zeros((N, M//2+1))
    vecs_minus = np.zeros((N, M//2-1))
    # Slowest to fastest index should be (row, irrep, column)
    # i.e. first count vectors in each irrep, then move to next irrep, then get components
    # We can then append the irreps together by just reshaping to (N, N-M)
    vecs0 = np.zeros((N, (s-1)//2, 2*M))

    # W∆ nonzero
    for i in range(M//2 - 1):
        ks = s * (i + 1 - M//4)
        up = ks % N
        down = (N//2 - ks) % N
        sign = 1 - 2*((M//4 + ks) & 1) # 1-2(q&1) == (-1)**q, but more fun
        vecs_plus[up, i+1] = 1 / np.sqrt(2)
        vecs_minus[up, i] = 1 / np.sqrt(2)
        vecs_plus[down, i+1] = sign / np.sqrt(2)
        vecs_minus[down, i] = -sign / np.sqrt(2)
    # Fixed points of W
    vecs_plus[N//4, -1] = 1
    vecs_plus[3*N//4, 0] = 1

    # W∆ = 0
    for j in range(1, (s + 1) // 2):
        for k in range(M):
            up = (j + k*s) % N
            down = (N//2 - j - k*s) % N
            vecs0[up, j-1, k] = 1
            vecs0[down, j-1, k+M] = 1 - 2*(up&1)
            
    vecs0_appended = np.reshape(vecs0, (N, N-M))
    # Orthogonal matrix maps a vector in the representation basis to the q-basis.
    to_qbasis = np.append(np.append(vecs_plus, vecs_minus, axis=1), vecs0_appended, axis=1)
    assert np.allclose(to_qbasis.T @ to_qbasis, np.eye(N)), "Matrix is not orthogonal."
    return to_qbasis



''' Cat map (and helper functions) including the full Gauss sum below. '''

def cat_unitary_gauss(N, A):
    """
    Quantizes the classical cat map with matrix A to a N-dimensional unitary.
    If there is a perturbation, it is passed as an N-dimensional unitary pert.
        (e.g. as returned by shear or typ_pshear)
    Can handle hidden symmetries by computing the Gauss sum explicity.
    """
    A11, A12, A21, A22 = A[0,0], A[0,1], A[1,0], A[1,1]
    if not (A11*A22 - A12*A21 == 1 and A11 + A22 > 2):
        raise ValueError("Invalid cat map matrix.")

    # Index-independent Gauss sum factor
    gcd = np.gcd(N, A12)
    a = N * A11 // gcd
    b = A12 // gcd
    assert np.gcd(a, b) == 1, 'a and b must be coprime'
    P = 1 / np.sqrt(b)
    if b % 2 == 0:
        jac = jacobi(b, a)
        a_reduced = a % 8
        P *= jac * np.exp(1j * np.pi * a_reduced / 4)
    else:
        jac = jacobi(a, b)
        P *= jac * np.exp(-1j * np.pi * (b - 1) / 4)

    # Index-dependent things
    U = np.empty((N,N), dtype=np.complex128)
    for j in np.arange(N):
        for k in np.arange(N):
            unpert = np.pi * (A22*j*j - 2*j*k + A11*k*k) / (N*A12)
            # Gauss sum things
            T = 0
            c_num = 2 * (A11*k - j)
            c = c_num // gcd
            if c_num % gcd == 0 and (a*b + c) % 2 == 0:
                if a*b % 2 == 0:
                    a_inv = pow(a.item(), -1, mod=b.item())
                    # modulo avoids issues with large N
                    a_reduced = a % (8*b)
                    c_reduced = c % (8*b)
                    num = (a_reduced * (a_inv * c_reduced)**2) % (8*b)
                    T = np.exp(-2j*np.pi * num / (8*b))
                else:
                    a4_inv = pow(4*a.item(), -1, mod=b.item())
                    # modulo avoids issues with large N
                    a_reduced = a % b
                    c_reduced = c % b
                    num = (2 * a_reduced * (a4_inv * c_reduced)**2) % b
                    T = np.exp(-2j*np.pi * num / b)
            # The unitary
            U[j,k] = np.sqrt(A12/N) * np.exp(1j * unpert) * P * T
    
    assert np.allclose(U @ U.conj().T, np.eye(N)), 'Map is not unitary'
    return U
    
    
def jacobi(a, b):
    """
    Computes the Jacobi symbol (a/b). This is 1, 0, or -1.
    a is an integer and b is a positive, odd integer.
    See https://en.wikipedia.org/wiki/Jacobi_symbol#Calculating_the_Jacobi_symbol for the algorithm.
    WARNING: Not sure if this will work for negative 'a' as Python and C modulo work differently.
    """
    if not (b > 0 and b % 2 == 1):
        raise ValueError("b must be positive and odd")
    out = 1
    a = a % b # Reduce
    while a != 0:
        # Factors of 2
        while a % 2 == 0:
            a = a // 2
            r = b % 8
            if r == 3 or r == 5:
                out = -out
        # Quadratic reciprocity allows swapping a,b
        # with possibly a change of sign
        if a % 4 == 3 and b % 4 == 3:
            out = -out
        a,b = b,a
        # Reduce again
        a = a % b
    if  b == 1:
        return out
    return 0
